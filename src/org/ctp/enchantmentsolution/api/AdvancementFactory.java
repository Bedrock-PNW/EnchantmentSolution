package org.ctp.enchantmentsolution.api;

import org.ctp.enchantmentsolution.api.shared.*;
import org.ctp.enchantmentsolution.api.trigger.*;
import org.ctp.enchantmentsolution.api.util.Validator;
import net.md_5.bungee.api.chat.TextComponent;
import org.apache.commons.lang.Validate;
import org.bukkit.Bukkit;
import org.bukkit.Material;
import org.bukkit.NamespacedKey;
import org.bukkit.craftbukkit.libs.jline.internal.Nullable;
import org.bukkit.plugin.Plugin;

import java.util.function.Function;

/**
 * A class containing methods which should drastically speed up the creation of
 * the common advancements. Also offers auto-activation functionalities.
 */
public class AdvancementFactory {
	private final Plugin plugin;
	private final boolean autoActivate;
	private final boolean autoReload;

	/**
	 * @param plugin
	 *            the advancements' ids will be created in this plugin's namespace
	 * @param autoActivate
	 *            whether the advancement should be automatically activated directly
	 *            after creation
	 * @param autoReload
	 *            whether {@link Bukkit#reloadData()} should be called immediately
	 *            after an advancement has been created. {@code autoActivate}
	 *            mustn't be false if this is true
	 */
	public AdvancementFactory(Plugin plugin, boolean autoActivate, boolean autoReload) {
		Validate.isTrue(!(!autoActivate && autoReload), "Auto reload doesn't't work without auto activation.");
		this.plugin = plugin;
		this.autoActivate = autoActivate;
		this.autoReload = autoReload;
	}

	/**
	 * Creates a new {@link Advancement} with the specified contents and possibly
	 * activates it (and possibly calls {@link Bukkit#reloadData()}) depending on
	 * the parameters passed in the constructor.
	 *
	 * @param id
	 *            the id of the advancement, without namespace
	 * @param parent
	 *            the parent advancement, can be null.
	 *            {@link #getRoot(String, String, String, Material, int, String)}
	 *            may be more suitable for root advancements
	 * @param title
	 *            the title of the advancement
	 * @param description
	 *            the description of the advancement
	 * @param icon
	 *            the icon of the advancement
	 * @param data
	 *            the icon's data value
	 * @param triggerId
	 *            the id of the trigger
	 * @param trigger
	 *            the trigger of the advancement
	 * @return the created advancement
	 */
	public Advancement getSimple(String id, @Nullable Advancement parent, String title, String description,
			Material icon, String triggerId, Trigger trigger) {
		validate(id, title, description, icon);
		Advancement advancement = new Advancement(new NamespacedKey(plugin, id), new ItemObject().setItem(icon),
				new TextComponent(title), new TextComponent(description)).addTrigger(triggerId, trigger);
		finalize(advancement, parent);
		return advancement;
	}

	/**
	 * Similar to
	 * {@link #getSimple(String, Advancement, String, String, Material, int, String, Trigger)},
	 * but this method adds multiple triggers, all of which must be completed in
	 * order to complete the advancement. The triggers are generated by iterating
	 * over the {@code contents} array and calling the {@code triggerCreator}
	 * function.
	 */
	public <T> Advancement getAll(String id, @Nullable Advancement parent, String title, String description,
			Material icon, T[] contents, Function<T, Trigger> triggerCreator) {
		validate(id, title, description, icon);
		Advancement advancement = new Advancement(new NamespacedKey(plugin, id), new ItemObject().setItem(icon),
				new TextComponent(title), new TextComponent(description));
		for(int i = 0; i < contents.length; i++) {
			advancement.addTrigger(String.valueOf(i), triggerCreator.apply(contents[i]));
		}
		finalize(advancement, parent);
		return advancement;
	}

	/**
	 * Similar to
	 * {@link #getSimple(String, Advancement, String, String, Material, int, String, Trigger)},
	 * but this method adds multiple triggers, only one of which must be completed
	 * in order to complete the advancement. The triggers are generated by iterating
	 * over the {@code contents} array and calling the {@code triggerCreator}
	 * function.
	 */
	public <T> Advancement getAny(String id, @Nullable Advancement parent, String title, String description,
			Material icon, T[] contents, Function<T, Trigger> triggerCreator) {
		validate(id, title, description, icon);
		Advancement advancement = new Advancement(new NamespacedKey(plugin, id), new ItemObject().setItem(icon),
				new TextComponent(title), new TextComponent(description));
		String[] requirements = new String[contents.length];
		for(int i = 0; i < contents.length; i++) {
			String index = String.valueOf(i);
			requirements[i] = index;
			advancement.addTrigger(index, triggerCreator.apply(contents[i]));
		}
		advancement.addRequirement(requirements);
		finalize(advancement, parent);
		return advancement;
	}

	/**
	 * Similar to
	 * {@link #getSimple(String, Advancement, String, String, Material, int, String, Trigger)},
	 * but this method creates an advancement which is automatically unlocked and
	 * has the specified background.
	 */
	public Advancement getRoot(String id, String title, String description, Material icon, String background) {
		validate(id, title, description, icon);
		Advancement advancement = new Advancement(new NamespacedKey(plugin, id), new ItemObject().setItem(icon),
				new TextComponent(title), new TextComponent(description)).makeRoot(background, true);
		finalize(advancement, null);
		return advancement;
	}

	/**
	 * This method creates an advancement which has multiple impossible triggers
	 * with the specified trigger ids.
	 * 
	 * @see #getSimple(String, Advancement, String, String, Material, int, String,
	 *      Trigger)
	 */
	public Advancement getImpossible(String id, @Nullable Advancement parent, String title, String description,
			Material icon, String... triggers) {
		validate(id, title, description, icon);
		Validate.notNull(triggers);
		Validate.isTrue(triggers.length > 0, "At least one trigger must be specified.");
		Advancement advancement = new Advancement(new NamespacedKey(plugin, id), new ItemObject().setItem(icon),
				new TextComponent(title), new TextComponent(description));
		for(String trigger: triggers) {
			advancement.addTrigger(trigger, new ImpossibleTrigger());
		}
		finalize(advancement, parent);
		return advancement;
	}

	/**
	 * @see #getImpossible(String, Advancement, String, String, Material, int)
	 */
	public Advancement getImpossible(String id, @Nullable Advancement parent, String title, String description,
			Material icon) {
		return getImpossible(id, parent, title, description, icon, "0");
	}

	/**
	 * Similar to
	 * {@link #getImpossible(String, Advancement, String, String, Material, int, String...)},
	 * but this method adds specified amount of triggers, with the ids starting with
	 * "0" and ending with the string value of {@code triggerCount - 1}
	 */
	public Advancement getCountedImpossible(String id, @Nullable Advancement parent, String title, String description,
			Material icon, int triggerCount) {
		validate(id, title, description, icon);
		Validate.isTrue(triggerCount > 0, "There must be at least one trigger.");
		Advancement advancement = new Advancement(new NamespacedKey(plugin, id), new ItemObject().setItem(icon),
				new TextComponent(title), new TextComponent(description));
		for(int i = 0; i < triggerCount; i++) {
			advancement.addTrigger(String.valueOf(i), new ImpossibleTrigger());
		}
		finalize(advancement, parent);
		return advancement;
	}

	private static void validate(String id, String title, String description, Material icon) {
		Validator.noNamespace(id);
		Validate.notNull(title);
		Validate.notNull(description);
		Validate.notNull(icon);
	}

	private void finalize(Advancement advancement, @Nullable Advancement parent) {
		if (parent != null) {
			advancement.makeChild(parent.getId());
		}
		if (autoActivate) {
			advancement.activate(autoReload);
		}
	}
}
